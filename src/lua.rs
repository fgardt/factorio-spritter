use std::{collections::BTreeMap, io::Write, path::Path};

#[derive(Debug, Clone)]
pub enum LuaValue {
    String(String),
    Float(f64),
    Int(i64),
    Bool(bool),
    Shift(f64, f64, usize),
    Require(String),
}

impl From<String> for LuaValue {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}

impl From<&str> for LuaValue {
    fn from(value: &str) -> Self {
        Self::String(value.to_owned())
    }
}

impl From<f64> for LuaValue {
    fn from(value: f64) -> Self {
        Self::Float(value)
    }
}

impl From<f32> for LuaValue {
    fn from(value: f32) -> Self {
        Self::Float(value as f64)
    }
}

impl From<isize> for LuaValue {
    fn from(value: isize) -> Self {
        Self::Int(value as i64)
    }
}

impl From<i64> for LuaValue {
    fn from(value: i64) -> Self {
        Self::Int(value)
    }
}

impl From<i32> for LuaValue {
    fn from(value: i32) -> Self {
        Self::Int(value as i64)
    }
}

impl From<i16> for LuaValue {
    fn from(value: i16) -> Self {
        Self::Int(value as i64)
    }
}

impl From<i8> for LuaValue {
    fn from(value: i8) -> Self {
        Self::Int(value as i64)
    }
}

impl From<usize> for LuaValue {
    fn from(value: usize) -> Self {
        Self::Int(value as i64)
    }
}

impl From<u64> for LuaValue {
    fn from(value: u64) -> Self {
        Self::Int(value as i64)
    }
}

impl From<u32> for LuaValue {
    fn from(value: u32) -> Self {
        Self::Int(value as i64)
    }
}

impl From<u16> for LuaValue {
    fn from(value: u16) -> Self {
        Self::Int(value as i64)
    }
}

impl From<u8> for LuaValue {
    fn from(value: u8) -> Self {
        Self::Int(value as i64)
    }
}

impl From<bool> for LuaValue {
    fn from(value: bool) -> Self {
        Self::Bool(value)
    }
}

impl From<(f64, f64, usize)> for LuaValue {
    fn from((shift_x, shift_y, res): (f64, f64, usize)) -> Self {
        Self::Shift(shift_x, shift_y, res)
    }
}

impl std::fmt::Display for LuaValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::String(value) => write!(f, "\"{value}\""),
            Self::Float(value) => write!(f, "{value}"),
            Self::Int(value) => write!(f, "{value}"),
            Self::Bool(value) => write!(f, "{value}"),
            Self::Shift(x, y, res) => write!(f, "{{x = {x} / {res}, y = {y} / {res}}}"),
            Self::Require(value) => write!(f, "require(\"{value}\")"),
        }
    }
}

pub struct LuaOutput {
    map: BTreeMap<String, LuaValue>,
}

impl LuaOutput {
    pub const fn new() -> Self {
        Self {
            map: BTreeMap::new(),
        }
    }

    pub fn set(mut self, key: impl AsRef<str>, value: impl Into<LuaValue>) -> Self {
        self.map.insert(key.as_ref().to_owned(), value.into());
        self
    }

    pub fn reexport(mut self, name: impl AsRef<str>) -> Self {
        self.map.insert(
            name.as_ref().to_owned(),
            LuaValue::Require(name.as_ref().to_owned()),
        );
        self
    }

    pub fn save(&self, path: impl AsRef<Path>) -> std::io::Result<()> {
        let mut file = std::fs::File::create(path)?;

        writeln!(
            file,
            "-- Generated by {} v{} - {}",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION"),
            env!("CARGO_PKG_REPOSITORY")
        )?;
        writeln!(file, "return {{")?;

        for (key, data) in &self.map {
            writeln!(file, "  [\"{key}\"] = {data},")?;
        }

        writeln!(file, "}}")?;

        Ok(())
    }
}
